<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="/components/@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
    <script src="/components/web-component-tester/browser.js"></script>
    <script type="module" src="../dist/pfe-card.js"></script>
  </head>
  <body>
    <style>
      .grid {
        display: grid;
        grid-gap: 10px;
        grid-template-columns: repeat(3, 1fr);
      }
      h2 {
        margin-bottom: 0;
      }
    </style>
    <div class="grid">

      <pfe-card id="card1">
        <h2 slot="pfe-card--header">Card 1</h2>
        <p>This is pfe-card.</p>
        <div slot="pfe-card--footer">Text in footer</div>
      </pfe-card>

      <pfe-card id="card2">
        <img src="https://placekitten.com/200/150"/>
      </pfe-card>

      <pfe-card id="card3">
        <h2 slot="pfe-card--header">Card 3</h2>
        <img src="https://placekitten.com/1000/500" pfe-overflow="top right bottom left"/>
      </pfe-card>

      <pfe-card id="card4">
        <h2 slot="pfe-card--header">Card 4</h2>
        <p>This is pfe-card.</p>
        <div slot="pfe-card--footer">Text in footer</div>
      </pfe-card>

      <pfe-card id="card5" pfe-border pfe-color="lightest">
        <h2 slot="pfe-card--header">Card 4</h2>
        <p>This is pfe-card.</p>
        <div slot="pfe-card--footer">Text in footer</div>
      </pfe-card>

      <pfe-card id="card6">
        <h2 slot="pfe-card--header">Card 1</h2>
        <p>This is pfe-card.</p>
        <div slot="pfe-card--footer">Text in footer</div>
      </pfe-card>
    </div>

    <script>
      const card = [...document.querySelectorAll("pfe-card")];

      // Returns the luminance value from rgb
      const luminance = (r, g, b) => (0.2126*r/255 + 0.7152*g/255 + 0.0722*b/255);

      // Converts a hex value to RGBA
      const hexToRgb = hex => {
        const [, r, g, b] = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/.exec(hex);
          return [
              parseInt(r, 16),
              parseInt(g, 16),
              parseInt(b, 16)
           ];
      };
      // Gets the rgba value from an element
      const getColor = (el, prop) => {
        const [, r, g, b] = getComputedStyle(el, null)[prop].match(/rgba?\((\d+),\s+(\d+),\s+(\d+).*\)/)
          .map(n => +n);
        return [r, g, b];
      };

      const updateVariable = (el, variable, value) => el.style.setProperty(variable, value);

      // Themes and their expected hex values
      const colors = {
        lightest: "#ffffff",
        lighter: "#ececec",
        base: "#dfdfdf",
        darker: "#464646",
        darkest: "#131313",
        accent: "#ee0000",
        complement: "#0477a4"
      };

      // Supported slots
      const slots = {
        header: {
          name: "pfe-card--header",
          class: "pfe-card__header",
          content: "Card 1"
        },
        body: {
          class: "pfe-card__body",
          content: "This is pfe-card."
        },
        footer: {
          name: "pfe-card--footer",
          class: "pfe-card__footer",
          content: "Text in footer"
        }
      };

      // Supported overflow attributes
      const overflow = {
        top: "",
        right: "",
        bottom: "",
        left: ""
      };

      // Supported hooks on the host element
      const customProperties = {
        paddingTop: {
          variable: "--pfe-card--PaddingTop",
          css: "padding-top",
          default:  "32px",
          custom: "28px"
        },
        paddingRight: {
          variable: "--pfe-card--PaddingRight",
          css: "padding-right",
          default:  "32px",
          custom: "28px"
        },
        paddingBottom: {
          variable: "--pfe-card--PaddingBottom",
          css: "padding-bottom",
          default:  "32px",
          custom: "28px"
        },
        paddingLeft: {
          variable: "--pfe-card--PaddingLeft",
          css: "padding-left",
          default:  "32px",
          custom: "28px"
        },
        padding: {
          variable: "--pfe-card--Padding",
          css: "padding",
          default:  "32px",
          custom: "20px 10px 20px 5px"
        },
        borderRadius: {
          variable: "--pfe-card--BorderRadius",
          css: "border-radius",
          default:  "3px",
          custom: "50%"
        },
        border: {
          variable: "--pfe-card--Border",
          css: "border-bottom",
          default:  "0px solid rgba(0, 0, 0, 0)",
          custom: "1px solid rgb(238, 238, 238)"
        },
        borderTop: {
          variable: "--pfe-card--BorderTop",
          css: "border-top",
          default:  "0px none rgb(51, 51, 51)",
          custom: "4px solid rgb(238, 0, 0)"
        },
        backgroundColor: {
          variable: "--pfe-card--BackgroundColor",
          css: "background-color",
          default:  "rgb(223, 223, 223)",
          custom: "rgb(255, 105, 180)"
        },
        backgroundPosition: {
          variable: "--pfe-card--BackgroundPosition",
          css: "background-position",
          default:  "50% 50%",
          custom: "100% 0%"
        }
      };

      const customProperties_header = {
        display: {
          variable: "--pfe-card__header--Display",
          css: "display",
          default:  "block",
          custom: "none"
        },
        backgroundColor: {
          variable: "--pfe-card__header--BackgroundColor",
          css: "background-color",
          default:  "rgba(45, 45, 45, 0.3)",
          custom: "rgb(255, 105, 180)"
        },
        color: {
          variable: "--pfe-card__header--Color",
          css: "color",
          default:  "rgb(51, 51, 51)",
          custom: "rgb(255, 105, 180)"
        }
      };

      suite("<pfe-card>", () => {
        test("it should upgrade", () => {
          assert.instanceOf(
            document.querySelector("pfe-card"),
            customElements.get("pfe-card"),
            "the <pfe-card> should be an instance of PfeCard"
          );
        });

        test("it should add or remove has_body, has_header, has_footer attributes if the slots exist", done => {
          const card = document.querySelector("#card4");
          assert.isTrue(card.hasAttribute("has_header"));
          assert.isTrue(card.hasAttribute("has_body"));
          assert.isTrue(card.hasAttribute("has_footer"));

          card.querySelector("h2").remove();
          card.querySelector("div").remove();

          flush(() => {
            assert.isFalse(card.hasAttribute("has_header"));
            assert.isFalse(card.hasAttribute("has_footer"));
            done();
          })
        });

        // Iterate over the colors object to test expected background color results
        Object.entries(colors).forEach(set => {
          test(`it should have a background color of ${set[1]} when pfe-color is ${set[0]}`, () => {
            // If this is not the default theme, update the color attribute
            if(set[0] !== "default") {
              card[0].setAttribute("pfe-color", set[0]);
            }
            // Get the background color value
            const [r, g, b] = getColor(card[0], "background-color");
            // Test that the color is rendering as expected
            assert.deepEqual([r, g, b], hexToRgb(set[1]));
            // Test that the theme is working
            if(["dark", "darker", "darkest", "complement", "accent"].includes(set[0])) {
              assert.isBelow(luminance(r, g, b), 0.5);
            }
            else {
              assert.isAbove(luminance(r, g, b), 0.5);
            }
          });
        });

        test("it should have standard padding when pfe-size is not set", () => {
          assert.equal(getComputedStyle(card[0], null)["padding"], "32px");
        });

        test("it should have reduced padding when pfe-size is small", () => {
          card[0].setAttribute("pfe-size", "small");
          assert.equal(getComputedStyle(card[0], null)["padding"], "16px");
        });

        test("it should have a standard border when pfe-border is set", () => {
          card[0].setAttribute("pfe-border", "");
          assert.deepEqual(getColor(card[0], "border-left-color"), hexToRgb("#d2d2d2"));
          assert.equal(getComputedStyle(card[0], null)["border-left-width"], "1px");
        });

        // Iterate over the slots object to test expected results
        Object.entries(slots).forEach(slot => {
          test(`${slot[0]} content is placed into correct slot`, () => {
            let selector = slot[0] !== "body" ? `[slot=${slot[1].name}]` : "p";
            assert.equal(
              card[0].querySelector(selector).assignedSlot,
              card[0].shadowRoot.querySelector(`.${slot[1].class} > *`)
            );

            const content = card[0].shadowRoot
              .querySelector(`.${slot[1].class} > *`)
              .assignedNodes()
              .map(n => n.textContent)
              .join("")
              .trim();
            assert.equal(content, slot[1].content);
          });
        });

        // Iterate over possibilities for images
        Object.entries(overflow).forEach(direction => {
          test(`image should overflow to the ${direction}`, () => {
            let image = card[1].querySelector("img");
            image.setAttribute("pfe-overflow", direction);
            setTimeout(function(){
              let margin = direction !== "bottom" ? "-32px" : "-35px";
              assert.equal(getComputedStyle(image, null)[`margin-${direction}`], margin);
            }, 50);
          });
        });

        test("image should overflow all padding", () => {
          let image = card[2].querySelector("img");
          setTimeout(function(){
            assert.equal(getComputedStyle(image, null)["margin-top"], "-16px");
            assert.equal(getComputedStyle(image, null)["margin-right"], "-32px");
            assert.equal(getComputedStyle(image, null)["margin-bottom"], "-35px");
            assert.equal(getComputedStyle(image, null)["margin-left"], "-32px");
          }, 50);
        });

        // Iterate over the custom properties to test overrides work
        Object.entries(customProperties).forEach(set => {
          Promise.all([customElements.whenDefined("pfe-card")]).then( () => {
            let property = set[1];

            // Test default value
            test(`${property.variable} picks up the default value`, () => {
              assert.equal(getComputedStyle(card[0], null)[property.css], property.default, `${property.css} should equal ${property.default}`);
            });

            // Update the variable
            test(`${property.variable} allows user customization`, () => {
              updateVariable(card[5], property.variable, property.custom);
              assert.equal(getComputedStyle(card[5], null)[property.css], property.custom, `${property.css} should equal ${property.custom}`);
            });
          });
        });

        // Iterate over the custom properties to test overrides work
        Object.entries(customProperties_header).forEach(set => {
          Promise.all([customElements.whenDefined("pfe-card")]).then( () => {
            let header = card[5].shadowRoot.querySelector(".pfe-card__header");
            let property = set[1];

            // Test default value
            test(`${property.variable} picks up the default value`, () => {
              assert.equal(getComputedStyle(header, null)[property.css], property.default, `${property.css} should equal ${property.default}`);
            });

            // Update the variable
            test(`${property.variable} allows user customization`, () => {
              updateVariable(card[5], property.variable, property.custom);
              assert.equal(getComputedStyle(header, null)[property.css], property.custom, `${property.css} should equal ${property.custom}`);
            });
          });
        });
      });
    </script>
  </body>
</html>
