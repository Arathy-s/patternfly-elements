<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="/components/@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
    <script src="/components/web-component-tester/browser.js"></script>
    <script type="module" src="../dist/pfe-card.js"></script>
  </head>
  <body>
    <test-fixture id="card">
      <template>
        <pfe-card>
          <h3 slot="pfe-card--header">Card header</h3>
          <p>This is pfe-card.</p>
          <div slot="pfe-card--footer">
            <p>Text in footer</p>
          </div>
        </pfe-card>
      </template>
    </test-fixture>

    <test-fixture id="simple-card">
      <template>
        <pfe-card>
          <p>This is pfe-card.</p>
        </pfe-card>
      </template>
    </test-fixture>

    <test-fixture id="image-card">
      <template>
        <pfe-card>
          <img src="https://placekitten.com/200/150"/>
        </pfe-card>
      </template>
    </test-fixture>

    <script>
      // Converts a hex value to RGBA
      const hexToRgb = hex => {
        const [, r, g, b] = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/.exec(hex);
          return [
              parseInt(r, 16),
              parseInt(g, 16),
              parseInt(b, 16)
           ];
      };
      // Gets the rgba value from an element
      const getColor = (el, prop) => {
        const [, r, g, b] = getComputedStyle(el, null)[prop].match(/rgba?\((\d+),\s+(\d+),\s+(\d+).*\)/)
          .map(n => +n);
        return [r, g, b];
      };
      // Updates the value of a custom property
      const updateVariable = (el, variable, value) => el.style.setProperty(variable, value);

      //-- Describe the component
      // Supported regions
      const regions = {
        header: {
          name: "pfe-card--header",
          class: "pfe-card__header",
          content: "Card header"
        },
        body: {
          class: "pfe-card__body",
          content: "This is pfe-card."
        },
        footer: {
          name: "pfe-card--footer",
          class: "pfe-card__footer",
          content: "Text in footer"
        },
        overlay: {
          class: "pfe-card__overlay"
        }
      };

      // Themes and their expected hex values
      const colors = {
        lightest: "#ffffff",
        lighter: "#ececec",
        base: "#dfdfdf",
        darker: "#464646",
        darkest: "#131313",
        accent: "#ee0000",
        complement: "#0477a4"
      };

      // Supported overflow attributes
      const overflow = ["top", "right", "bottom", "left"];

      // Supported hooks on the host element
      const customProperties = {
        display: {
          variable: "--pfe-card--Display",
          css: "display",
          default:  "flex",
          custom: "inline-block"
        },
        flexDirection: {
          variable: "--pfe-card--FlexDirection",
          css: "flex-direction",
          default:  "column",
          custom: "row"
        },
        borderRadius: {
          variable: "--pfe-card--BorderRadius",
          css: "border-radius",
          default:  "3px",
          custom: "50%"
        },
        border: {
          variable: "--pfe-card--Border",
          css: "border-bottom",
          default:  "0px solid rgba(0, 0, 0, 0)",
          custom: "1px solid rgb(238, 238, 238)"
        },
        borderTop: {
          variable: "--pfe-card--BorderTop",
          css: "border-top",
          default:  "0px solid rgba(0, 0, 0, 0)",
          custom: "4px solid rgb(238, 0, 0)"
        },
        backgroundColor: {
          variable: "--pfe-card--BackgroundColor",
          css: "background-color",
          default:  "rgb(223, 223, 223)",
          custom: "rgb(255, 105, 180)"
        },
        backgroundPosition: {
          variable: "--pfe-card--BackgroundPosition",
          css: "background-position",
          default:  "50% 50%",
          custom: "100% 0%"
        }
      };

      const customProperties_header = {
        display: {
          variable: "--pfe-card__header--Display",
          css: "display",
          default:  "flex",
          custom: "none"
        },
        backgroundColor: {
          variable: "--pfe-card__header--BackgroundColor",
          css: "background-color",
          default:  "rgba(45, 45, 45, 0.3)",
          custom: "rgb(255, 105, 180)"
        },
        color: {
          variable: "--pfe-card__header--Color",
          css: "color",
          default:  "rgb(51, 51, 51)",
          custom: "rgb(255, 105, 180)"
        }
      };

      const customProperties_body = {
        paddingTop: {
            variable: "--pfe-card--PaddingTop",
            css: "padding-top",
            default:  "32px",
            custom: "28px"
          },
          paddingRight: {
            variable: "--pfe-card--PaddingRight",
            css: "padding-right",
            default:  "32px",
            custom: "28px"
          },
          paddingBottom: {
            variable: "--pfe-card--PaddingBottom",
            css: "padding-bottom",
            default:  "32px",
            custom: "28px"
          },
          paddingLeft: {
            variable: "--pfe-card--PaddingLeft",
            css: "padding-left",
            default:  "32px",
            custom: "28px"
          }
      };

      suite("<pfe-card>", () => {
        let cards = {};
        let card;

        setup(() => {
          // Instantiate the card templates
          cards.default = fixture("card");
          cards.simple = fixture("simple-card");
          cards.image = fixture("image-card");
        });
        
        test("it should upgrade", () => {
          assert.instanceOf(
            document.querySelector("pfe-card"),
            customElements.get("pfe-card"),
            "the <pfe-card> should be an instance of PfeCard"
          );
        });

        // Check the schema for supported slots
        ["header", "footer"].forEach(slot => {
          // Iterate over the slots object to test expected results
          test(`${slot} content is placed into correct slot`, () => {
            card = cards.default;
            let className = regions[slot].class;
            let expected = regions[slot].content;
            
            // Check that the right elements are assigned to the slots            
            assert.equal(
              card.querySelector(`[slot="pfe-card--${slot}"]`).assignedSlot,
              card.shadowRoot.querySelector(`.${className} > *`)
            );

            let content = card.shadowRoot
              .querySelector(`.${className} > *`)
              .assignedNodes()
              .map(n => n.textContent)
              .join("")
              .trim();

            // Check that the expected content is in the right slot
            assert.equal(content, expected);
          });
          
          test(`it should add has_${slot} if the slot exist`, () => {
            card = cards.default;
            assert.isTrue(cards.default.hasAttribute(`has_${slot}`));
          });
          
          test(`it should remove has_${slot} if the slot does not exist`, () => {
            card = cards.simple;
            assert.isFalse(card.hasAttribute(`has_${slot}`));
          });
        });

        test(`body content is placed into correct slot`, () => {
          card = cards.default;
          let className = regions.body.class;
          let expected = regions.body.content;

          // Check that the right elements are assigned to the slots
          assert.equal(
            card.querySelector("p").assignedSlot,
            card.shadowRoot.querySelector(`.${className} > *`)
          );

          let content = card.shadowRoot
            .querySelector(`.${className} > *`)
            .assignedNodes()
            .map(n => n.textContent)
            .join("")
            .trim();

          // Check that the expected content is in the right slot
          assert.equal(content, expected);
        });

        // Iterate over the colors object to test expected background color results
        Object.entries(colors).forEach(set => {
          let label = set[0];
          let color = set[1];

          test(`it should have a background color of ${color} when pfe-color is ${label}`, () => {
            card = cards.default;

            // If this is not the default theme, update the color attribute
            if(label !== "default") {
              card.setAttribute("pfe-color", label);
            }

            // Get the background color value
            const [r, g, b] = getColor(card, "background-color");

            // Test that the color is rendering as expected
            assert.deepEqual([r, g, b], hexToRgb(color));

            // Test that the theme is working
            if(["dark", "darker", "darkest"].includes(label)) {
              assert.equal(card.getAttribute("on"), "dark");
            }
            else if(["complement", "accent"].includes(label)) {
              assert.equal(card.getAttribute("on"), "saturated");
            }
            else {
              assert.equal(card.getAttribute("on"), "light");
            }
          });
        });

        test("it should have standard padding when pfe-size is not set", () => {
          let body;
          card = cards.simple;
          body = card.shadowRoot.querySelector(`.${regions.body.class}`);
          assert.equal(getComputedStyle(body, null)["padding"], "32px");
        });

        test("it should have reduced padding when pfe-size is small", done => {
          let body;
          card = cards.simple;
          body = card.shadowRoot.querySelector(`.${regions.body.class}`);

          // Set the size attribute
          card.setAttribute("pfe-size", "small");

          flush(() => {
            assert.equal(getComputedStyle(body, null)["padding"], "16px");
            done();
          });
        });

        test("it should have a standard border when pfe-border is set", done => {
          card = cards.default;

          // Set the border attribute
          card.setAttribute("pfe-border", "");

          flush(() => {
            assert.deepEqual(getColor(cards.default, "border-left-color"), hexToRgb("#d2d2d2"));
            assert.equal(getComputedStyle(cards.default, null)["border-left-width"], "1px");
            done();
          });
        });

        // Iterate over possibilities for images
        overflow.forEach(direction => {
          test(`image should overflow to the ${direction}`, done => {
            let image;
            card = cards.image;
            image = card.querySelector("img");

            // Set overflow property
            image.setAttribute("pfe-overflow", direction);

            flush(() => {
              assert.equal(getComputedStyle(image, null)[`margin-${direction}`], "-32px");
              done();
            });
          });
        });

        test("image should overflow all padding", done => {
          let image;
          card = cards.image;
          image = card.querySelector("img");

          // Set overflow property
          image.setAttribute("pfe-overflow", "top right bottom left");

          flush(() => {
            assert.equal(getComputedStyle(image, null)["margin-top"], "-32px");
            assert.equal(getComputedStyle(image, null)["margin-right"], "-32px");
            assert.equal(getComputedStyle(image, null)["margin-bottom"], "-32px");
            assert.equal(getComputedStyle(image, null)["margin-left"], "-32px");
            done();
          });
        });

        // Iterate over the custom properties to test overrides work
        Object.entries(customProperties).forEach(set => {
          const property = set[1];

          // Test default value
          test(`${property.variable} picks up the default value`, () => {            
            assert.equal(getComputedStyle(cards.default, null)[property.css], property.default, `${property.css} should equal ${property.default}`);
          });

          // Update the variable
          test(`${property.variable} allows user customization`, done => {
            updateVariable(cards.default, property.variable, property.custom);

            flush(() => {
              Promise.all([customElements.whenDefined("pfe-card")]).then( () => {
                assert.equal(getComputedStyle(cards.default, null)[property.css], property.custom, `${property.css} should equal ${property.custom}`);
              });
              done();
            });
          });
        });

        // Iterate over the custom properties to test overrides work
        Object.entries(customProperties_body).forEach(set => {
          let property = set[1];
          let body;

          // Test default value
          test(`${property.variable} picks up the default value`, () => {
            card = cards.simple;
            body = card.shadowRoot.querySelector(`.${regions.body.class}`);

            assert.equal(getComputedStyle(body, null)[property.css], property.default, `${property.css} should equal ${property.default}`);
          });

          // Update the variable
          test(`${property.variable} allows user customization`, done => {
            card = cards.simple;
            body = card.shadowRoot.querySelector(`.${regions.body.class}`);
            
            updateVariable(card, property.variable, property.custom);

            flush(() => {
              assert.equal(getComputedStyle(body, null)[property.css], property.custom, `${property.css} should equal ${property.custom}`);
              done();
            });
          });
        });

        // Test that the general Padding property works
        test(`--pfe-card--Padding allows user customization`, done => {
          let body;
          card = cards.simple;
          body = card.shadowRoot.querySelector(`.${regions.body.class}`);
          
          updateVariable(card, "--pfe-card--Padding", "10px 5px");
          card.updateVariables();

          flush(() => {
            assert.equal(getComputedStyle(body, null)["padding-top"], "10px", "padding-top should equal 10px");
            assert.equal(getComputedStyle(body, null)["padding-right"], "5px", "padding-right should equal 5px");
            assert.equal(getComputedStyle(body, null)["padding-bottom"], "10px", "padding-bottom should equal 10px");
            assert.equal(getComputedStyle(body, null)["padding-left"], "5px", "padding-left should equal 5px");
            done();
          });
        });

        // Iterate over the custom properties to test overrides work
        Object.entries(customProperties_header).forEach(set => {
          let property = set[1];
          let header;

          // Test default value
          test(`${property.variable} picks up the default value`, () => {
            card = cards.default;
            header = card.shadowRoot.querySelector(`.${regions.header.class}`);

            assert.equal(getComputedStyle(header, null)[property.css], property.default, `${property.css} should equal ${property.default}`);
          });

          // Update the variable
          test(`${property.variable} allows user customization`, done => {
            card = cards.default;
            header = card.shadowRoot.querySelector(`.${regions.header.class}`);
            
            updateVariable(card, property.variable, property.custom);

            flush(() => {
              assert.equal(getComputedStyle(header, null)[property.css], property.custom, `${property.css} should equal ${property.custom}`);
              done();
            });
          });
        });
      });
    </script>
  </body>
</html>
